# Junior JavaScript Interview Questions — Answers

## Загальні

1. **Які методи HTTP-запитів ви знаєте?**  
   GET, POST, PUT, PATCH, DELETE, OPTIONS, HEAD.

2. **Які версії HTTP-протоколу вам відомі?**  
   HTTP/1.0, HTTP/1.1, HTTP/2, HTTP/3.

3. **Які знаєте коди відповіді (стану) `HTTP?`**  
   1xx — інформаційні,
   2xx — успішні,
   3xx — редиректи,
   4xx — помилки клієнта,
   5xx — помилки сервера.

4. **Що таке Cross-Origin Resource Sharing? Як усунути проблеми з CORS?**  
   Механізм безпеки браузера для контролю доступу з інших доменів.  
   Вирішення: налаштувати `Access-Control-Allow-Origin`, `Access-Control-Allow-Methods`, `Access-Control-Allow-Headers`.

5. **Що таке cookie?**  
   Невеликі дані, що зберігаються у браузері для сесій, авторизації, налаштувань.

6. **Який максимальний розмір cookie?**  
   ~4 KB на один cookie.

7. **Що означає директива `use strict?`**  
   Вмикає строгий режим — забороняє небезпечні конструкції і помилки, які JS зазвичай ігнорує.
   Приклад:

   ```js
   "use strict";

   x = 10; // Викине помилку ReferenceError
   let y = 20; // Правильно
   ```

8. **Чим `JS` відрізняється під час роботи на `front-end` і `back-end`?**  
   `Front-end` — працює у браузері, має DOM, обмежений доступ до системи.  
   `Back-end` — Node.js, доступ до файлової системи, мережі, процесів.

9. **Що таке статична і динамічна типізації?**  
   Статична — типи визначаються компілятором.
   Динамічна — тип визначається під час виконання.

   Приклад статичної:

   ```java
    int x = 10;  // x = ціле число
    x = 20;      // ОК
    x = "Hello"; // Помилка компіляції, не можна присвоїти рядок змінній int
   ```

   Приклад динамічної:

   ```js
   let x = 10; // x = число
   console.log(typeof x); // "number"

   x = "Hello"; // тип змінюється на рядок
   console.log(typeof x); // "string"
   ```

10. **Як клієнт взаємодіє із сервером?**  
    Через HTTP-запити. Клієнт відправляє запит → сервер відповідає.

11. **Що таке `REST`?**  
    Архітектурний стиль для побудови API: ресурси, методи HTTP, статуси відповіді.

12. **Поясніть поняття мутабельність / іммутабельність? Які типи є мутабельними й навпаки?**  
    Мутабельні — Їх можна змінювати після створення. Наприклад, об’єкти та масиви.  
    Іммутабельні — Їх не можна змінити після створення. Наприклад, числа, рядки, булеві значення.

    Мутабельні:

    ```js
    // Масив
    let arr = [1, 2, 3];
    arr.push(4); // Додаємо елемент
    console.log(arr); // [1, 2, 3, 4]

    // Об’єкт
    let obj = { name: "Alice", age: 25 };
    obj.age = 26; // Змінюємо значення
    console.log(obj); // { name: "Alice", age: 26 }
    ```

    Іммутабельні:

    ```js
    // Число
    let num = 10;
    num = num + 5; // Створюється нове число, старе не змінюється
    console.log(num); // 15

    // Рядок
    let str = "Hello";
    let newStr = str.toUpperCase(); // Створюється новий рядок
    console.log(str); // "Hello" оригінал не змінився
    console.log(newStr); // "HELLO"
    ```

13. **Як шукати помилки в коді? Чи використовуєте дебагер?**  
    Використовую `console.log()` та DevTools.

14. **Яких відомих людей зі світу JS знаєте?**  
    Brendan Eich, Douglas Crockford, Ryan Dahl.

---

## JS Core

15. **Які існують типи даних у JS?**  
    `string`, `number`, `object`, `null`, `undefined`...

16. **Як перевірити, чи об’єкт є масивом?**
    `Array.isArray(arr)`.
    Приклад:

    ```js
    let arr = [1, 2, 3];
    console.log(Array.isArray(arr)); // true

    let obj = { a: 1 };
    console.log(Array.isArray(obj)); // false
    ```

17. **Як перевірити, чи число є скінченним?**  
    `Number.isFinite(num)`.

18. **Як перевірити, що змінна рівна `NaN?`**  
    `Number.isNaN(x)`.

19. **Чим відрізняється поведінка `isNaN()` та `Number.isNaN()`?**  
    `isNaN()` — приводить тип до числа перед перевіркою.  
    `Number.isNaN()` — повертає `true` тільки тоді, коли аргумент буквально є значенням `NaN`.
    ```js
    //isNaN():
    isNaN("abc"); // true  -> "abc" перетворюється на NaN
    isNaN("123"); // false -> "123" перетворюється на число 123
    ```

    ```js
    //Number.isNaN():
    Number.isNaN("abc"); // false  -> рядок не приводиться до числа
    Number.isNaN(NaN); // true   -> справжній NaN
    ```

20. **Порівняйте ключові слова `var`, `let`, `const`.**  
    `var` — Має функціональну або глобальну область видимості, ігнорує блоки `{}`.  
    `let` — Мають блокову область видимості, можна перевизначити.  
    `const` — Мають блокову область видимості, не можна перевизначити.
    `var`:
    ```js
    if (true) {
      var x = 10;
    }
    console.log(x); // 10  -> доступний ЗА межами блоку
    ```
    `let`:
    ```js
    if (true) {
        let a = 10;
        a = 5
        console.log(a); // Виведе 5
    }
    console.log(a); // Помилка
    ```
    `const`:
    ```js
    if (true) {
        const a = 10;
        a = 5       // Помилка
        console.log(a);
    }
    console.log(a); // Помилка
    ```

21. **Що таке область видимості?**  
    Це частина коду, в межах якої певна змінна доступна (видима). Іншими словами, де можна використовувати змінну, а де — ні.

22. **Що таке деструктуризація?**  
    Витягування значень з масивів або об’єктів у змінні.

23. **Для чого призначені методи setTimeout і setInterval?**  
    setTimeout — виконати функцію один раз після затримки.  
    setInterval — виконувати функцію періодично.

24. **Порівняйте підходи роботи з асинхронним кодом: callbacks vs promises vs async/await.**  
    Callbacks — функція приймає іншу функцію як аргумент і викликає її після завершення асинхронної операції.  
    Promises — promise представляє значення, яке з’явиться у майбутньому. Дозволяє будувати чисті ланцюжки `.then()` і обробляти помилки `.catch()`.
    async/await — дозволяє писати асинхронний код як синхронний.

25. **Чи можна записувати нові властивості / функції в прототипи стандартних класів (Array, Object тощо)? Чому ні? У яких випадках це робити можна? Як убезпечити себе, якщо потрібно розширити прототип?**  
    Не рекомендується — може зламати сторонній код.  
    Дозволено у контрольованому середовищі, перевіряючи `Object.hasOwn()`.

26. **Назвіть методи масивів, які пам’ятаєте, і скажіть, для чого вони потрібні.**  
    push, pop, shift, unshift, map, filter, reduce, find, some, every, forEach, includes.

27. **Які перебираючі методи масиву знаєте? У чому їхня відмінність?**  
    map — створює новий масив.  
    filter — відбирає елементи.  
    reduce — агрегує значення.  
    forEach — просто перебір.  
    find — повертає перший елемент, що задовольняє умову.

28. **Як працюють оператори присвоєння / порівняння / рядкові / арифметичні / бітові тощо?**  
    Присвоєння `=` — використовуються для запису значення у змінну.
    Порівняння `==`, `===` — повертають true або false.
    Рядкові `+` — об’єднують строки.
    Арифметичні `+`, `-`, `*`, `/`, `%` — обчислення.
    Логічні `&&`, `||`, `!` — працюють із логічними значеннями.
    Бітові `&`, `|`, `^`, `~`, `<<`, `>>`, `>>>` — операції на рівні бітів.

29. **Опишіть призначення і принципи роботи з колекціями Map і Set.**  
    Map — колекція для зберігання пар ключ–значення, де ключі можуть бути будь-якого типу (на відміну від об’єкта, де ключі завжди рядки або символи). Принципи роботи: Ключі унікальні. Якщо додати ключ, який вже існує → старе значення перезаписується. Підтримує порядок вставки. Має вбудовані методи для роботи з елементами.
    \
    Set — колекція для зберігання унікальних значень будь-якого типу. Принципи роботи: Значення не повторюються. Порядок елементів зберігається. Ідеально підходить для фільтрації унікальних елементів.

30. **Що означає глибока (deep) та поверхнева (shallow) копія об’єкта? Як зробити кожну з них?**  
    Shallow — Створюється новий об’єкт, але вкладені об’єкти та масиви залишаються посиланнями на старі. Зміни у вкладених структурах впливають на оригінал. `{ ...obj }` або `Object.assign({}, obj)`  
    Deep — Створюється повністю незалежний об’єкт, включно з усіма вкладеними об’єктами. Зміни в копії не впливають на оригінал.`structuredClone(obj)` або `JSON.parse(JSON.stringify(obj))`.

---

## Функції

31. **Яка різниця між декларацією функції (function declaration) та функціональним виразом (function expression)?**  
    Declaration — піднімається (hoisting).  
    Expression — присвоюється змінній.

32. **Що таке анонімна функція?**  
    Функція без імені: `() => {}`.

33. **Розкажіть про стрілкові функції (arrow function). В чому полягають відмінності стрілкових функцій від звичайних?**  
    Не мають власного `this`, `arguments` та `prototype`. Коротший синтаксис.

34. **Що таке і для чого використовують IIFE (Immediately Invoked Function Expression)?**  
    Функція, що викликається одразу: `(function(){})();`.  
    Використовується для локальної області видимості.

35. **Що таке hoisting, як він працює для змінних і функцій?**  
    Підняття оголошень на початок області видимості.  
    Функції піднімаються повністю, var — з undefined.

36. **Що таке замикання (closure) і які сценарії його використання?**  
    Функція пам’ятає змінні зовнішньої області навіть після завершення виконання зовнішньої функції.

37. **Приклад із setTimeout (що виведе в консоль і чому)**

    ```js
    var f = function () {
      console.log(1);
    };
    var execute = function (f) {
      setTimeout(f, 1000);
    };
    execute(f);
    f = function () {
      console.log(2);
    };
    ```

    Виведе 1, бо в момент виклику execute, f ще дорівнює першій функції.

38. **Рекурсія**
    Функція, що викликає саму себе.
    Приклад:

    ```js
    function factorial(n) {
      if (n === 1) return 1;
      return n * factorial(n - 1);
    }
    ```

39. **this**
    Контекст виконання — те, на що вказує `this` у момент виклику.

    ```js
    const user = {
      name: "Danil",
      sayHi() {
        console.log(this.name);
      },
    };
    ```

40. **Втрата контексту**
    Виникає, коли метод передають як callback:

    ```js
    const obj = {
      num: 5,
      print() {
        console.log(this.num);
      },
    };

    setTimeout(obj.print, 1000); // undefined
    ```

    Вирішення:

    ```js
    setTimeout(obj.print.bind(obj), 1000);
    ```

41. **bind / call / apply**

    ```js
    function greet(a, b) {
      console.log(this.name, a, b);
    }

    const user = { name: "Danil" };

    greet.call(user, 1, 2); // викликає одразу
    greet.apply(user, [1, 2]); // те саме, але масив аргументів
    const fn = greet.bind(user, 1, 2); // повертає нову функцію
    fn();
    ```

---

## Front-end

42. **DOM**
    Дерево елементів HTML.

    ```js
    const el = document.querySelector("#box");
    ```

43. **async vs defer**

    ```html
    <script src="a.js" async></script>
    <script src="b.js" defer></script>
    ```

    async — виконується як тільки завантажився  
    defer — після повного парсингу HTML

44. **innerHTML vs innerText**

    ```js
    div.innerHTML = "<b>Bold</b>";
    div.innerText = "<b>Not bold</b>";
    ```

45. **Bubbling**
    Подія іде знизу вверх по DOM.

46. **Зупинити bubbling**

    ```js
    event.stopPropagation();
    ```

47. **Зупинити дефолтну дію**

    ```js
    event.preventDefault();
    ```

48. **this у handler'і**

    ```js
    button.onclick = function () {
      console.log(this); // button
    };
    ```

49. **LocalStorage / SessionStorage**

    ```js
    localStorage.setItem("key", "value");
    localStorage.getItem("key");
    ```

50. **Висота блоку / позиція**

    ```js
    element.offsetHeight;
    element.getBoundingClientRect();
    ```

51. **webpack**
    Бандлер — збирає модулі в один файл.
    Приклад config-а:

    ```js
    module.exports = {
      entry: "./src/index.js",
      output: { filename: "bundle.js" },
    };
    ```

52. **dev vs prod**
    dev — з sourcemaps і без оптимізації  
    prod — мінімізація та tree-shaking
    ```js
    webpack --mode production
    webpack --mode development
    ```

---

## Верстка

53. **Що таке блокова модель CSS?**  
    Кожен елемент на сторінці представлений прямокутником, що складається з content, padding, border і margin.

54. **Які способи центрування блокового контенту по горизонталі та вертикалі знаєте?**  
    Горизонтально: `margin: 0 auto`, flex `justify-content: center`.  
    Вертикально: flex `align-items: center`, grid `place-items: center`.

55. **Які підходи у верстці вам відомі (float, flex, grid, etc)?**  
    Float, Flexbox, CSS Grid, inline-block, позиціонування (absolute, relative, fixed).

56. **Як зробити додаток responsive?**  
    Media queries, flex/grid, відсоткові ширини, viewport units, max-width.

57. **Які є принципи семантичної верстки?**  
    Використання тегів за призначенням (`<header>`, `<article>`, `<footer>`), доступність (accessibility), SEO.

58. **Навіщо потрібні префікси для деяких CSS-властивостей (-webkit-, -moz- тощо)?**  
    Для сумісності зі старими браузерами, що підтримують властивості нестандартно.

59. **Як спростити написання кросбраузерних стилів?**  
    Використовувати Autoprefixer, normalize.css, CSS reset.

60. **Практичне завдання: прокоментувати та виправити приклад поганого CSS або HTML.**  
    Використовувати семантичні теги, прибрати !important, уникати fixed px, застосувати flex/grid для розташування.

61. **Що таке CSS-препроцесори? З якими працювали? Що нового вони приносять у стандартний CSS?**  
    Sass, LESS, Stylus — додають змінні, міксіни, вкладення, функції для спрощення коду.

---

## Angular

62. **Перерахуйте основні компоненти фреймворку (модуль, роут, директива тощо).**  
    Module, Component, Directive, Service, Pipe, Route.

63. **У чому різниця між компонентом і директивою?**  
    Компонент — UI + логіка. Директива — поведінка елемента або DOM.

64. **Розкажіть про життєвий цикл компонента.**  
    Створення → Ініціалізація → Оновлення → Знищення.

65. **Перерахуйте часто використовувані хуки життєвого циклу компонента та розкажіть, для чого вони потрібні?**  
    ngOnInit, ngOnChanges, ngDoCheck, ngAfterViewInit, ngOnDestroy — керують логікою під час життєвого циклу компонента.

66. **У чому різниця між конструктором і ngOnInit-хуком?**  
    Конструктор — ініціалізація залежностей. ngOnInit — логіка після створення компоненту.

67. **Як захистити роут від несанкціонованого доступу? Які механізми надає для цього фреймворк?**  
    Route guards (`CanActivate`, `CanLoad`), AuthService.

68. **Що таке Lazy loading, як і для чого використовується?**  
    Завантаження модулів тільки при необхідності для економії ресурсів.

69. **Яке призначення RouterOutlet?**  
    Місце для рендерингу компонентів маршруту.

70. **Як компоненти можуть взаємодіяти один з одним?**  
    Input/Output, EventEmitter, сервіси для спільного стану.

71. **Як створити two-way binding властивість для компонента?**  
    Синтаксис `[()]` — `<input [(ngModel)]="property">`.

72. **Які типи форм є у фреймворку? У яких випадках і що краще використовувати?**  
    Template-driven (NgForm), Reactive (FormGroup/FormControl).

73. **Які стани є у форми і як це можна застосувати?**  
    valid/invalid, touched/untouched, dirty/pristine, pending.

74. **Навіщо потрібні сервіси? Як з ними працювати?**  
    Інкапсулюють логіку та стан, використовуються через Dependency Injection.

75. **Що таке singleton-сервіси? Яке їхнє призначення? Спосіб створення?**  
    Єдиний екземпляр на весь додаток, забезпечує спільний стан, створюється через `providedIn: 'root'`.

76. **Які є способи оголошення сервісів?**  
    `providedIn: 'root'`, providers у модулі або компоненті.

77. **Для чого потрібні модулі? Скільки їх має бути в проєкті?**  
    Організація коду; Core, Shared, Feature, кількість залежить від проєкту.

78. **Навіщо потрібні загальні модулі (shared)?**  
    Для повторно використовуваних компонентів, директив, пайпів.

79. **Які переваги типізації в TypeScript?**  
    Безпечний код, автодоповнення, перевірка помилок під час компіляції.

80. **Які можливості TypeScript можна використовувати для типізації (тут мають на увазі інтерфейси, типи, enum тощо)?**  
    Interfaces, Types, Enums, Generics, Tuple.

81. **Яка різниця між інтерфейсом і класом?**  
    Інтерфейс описує форму даних, клас — реалізацію.

82. **У чому різниця між інтерфейсом і абстрактним класом?**  
    Інтерфейс — лише сигнатури, абстрактний клас — часткова реалізація.

83. **Яка різниця між інтерфейсом і типом?**  
    type можна комбінувати, об’єднувати; interface — розширювати.

84. **Що таке RxJS? Як він використовується у фреймворку? Які компоненти фреймворку тісно пов’язані з ним?**  
    Observables для HTTP, forms, event streams; інтегрується з async pipe та HttpClient.

85. **Чим відрізняються Observable і Promise?**  
    Observable — багато значень, lazy; Promise — одне значення, eager.

86. **Для чого потрібні Subjects? Які типи Subjects існують?**  
    Subjects — multicasting Observables. Типи: Subject, BehaviorSubject, ReplaySubject, AsyncSubject.

87. **Як зробити кілька послідовних запитів до API за допомогою HTTP-сервісу і RxJS?**  
    Використання pipe + switchMap/concatMap/mergeMap.

88. **Яка різниця між switchMap, concatMap, mergeMap?**  
    switchMap — скасовує попередній, concatMap — послідовно, mergeMap — паралельно.

89. **Як можна конфігурувати Angular-застосунок?**  
    angular.json, environment.ts, імпорт модулів, providers.

90. **Навіщо потрібні environment-файли? Коли їх краще не використовувати?**  
    Для різних середовищ (dev, prod); не для секретних ключів.

91. **У чому різниця між «розумним» (smart) і «дурним» (dumb) компонентами? У яких випадках застосовується кожен з них?**  
    Smart — логіка, state; Dumb — презентація, отримує дані через Input.

92. **У чому різниця між NgForm, FormGroup і FormControl і як їх застосовують для побудови форм?**  
    NgForm — template-driven; FormGroup/FormControl — reactive forms.

93. **Навіщо потрібен і як працює async pipe?**  
    Автоматично підписується на Observable і відписується.

94. **Як стежити за розвитком фреймворку? Яких відомих людей, пов’язаних з Angular, знаєте / читаєте?**  
    Оф. документація, GitHub, блоги; Misko Hevery.

---

## React

95. **Чи працювали з класовими компонентами? У чому їхня особливість?**  
    Мають state та lifecycle methods. `class MyComp extends React.Component {}`

96. **Які дані краще зберігати в стані компонента, а які передавати через пропси? Наведіть приклад.**  
    State — локальний стан компонента. Props — дані від батьків.

97. **Чи ознайомлені з хуками? У чому їхні переваги? Чи доводилося робити свої і з якою метою?**  
    useState, useEffect, useMemo, useCallback; зручні для функціональних компонентів.

98. **Чи ознайомлені з фрагментами та порталами? Навіщо вони потрібні?**  
    Fragments `<></>` — без дод. DOM елемента. Portals — рендер у інший DOM вузол.

99. **Коли й для чого використовують рефи?**  
    Доступ до DOM елемента або збереження mutable значень.

100.  **Які ви знаєте методи життєвого циклу компонента?**  
      componentDidMount, componentDidUpdate, componentWillUnmount.

101.  **В якому методі життєвого циклу компонента краще робити запити на сервер? Чому?**  
      componentDidMount — після рендеру.

102.  **В якому методі життєвого циклу компонента краще робити підписку і відписку від лістенера? Чому? Навіщо відписуватися?**  
      useEffect або componentWillUnmount; відписка потрібна для уникнення memory leaks.

103.  **Чи був досвід роботи з контекстом? Коли його варто використовувати?**  
      Глобальний стан, коли props drilling незручний.

104.  **У чому особливість PureComponent?**  
      Оптимізація рендерингу через shallow comparison props/state.

105.  **Чи працював з мемоізованими селекторами (memoized selectors)? Для чого їх використовують і який принцип роботи?**  
      useMemo, reselect; кешують обчислення для оптимізації.

106.  **У чому бачите переваги бібліотеки React?**  
      Компонентна архітектура, Virtual DOM, простота інтеграції.

107.  **Чому бібліотека React швидка? Що таке Virtual DOM і Shadow DOM?**  
      Virtual DOM мінімізує реальні маніпуляції з DOM. Shadow DOM — інкапсуляція стилів компонентів.

108.  **Навіщо в списках ключі? Чи можна робити ключами індекси елементів масиву? Коли це виправдано?**  
      Ключі — для відслідковування елементів. Індекси — тільки для статичних списків.

109.  **В чому основна ідея Redux?**  
      Центральний store, unidirectional data flow, predictability.

110.  **Робота зі стилями в React.**  
      CSS Modules, styled-components, inline styles, SASS/LESS.

111.  **React — це бібліотека чи фреймворк? Яка різниця між цими двома поняттями.**  
      React — бібліотека UI, не повний фреймворк.

112.  **Чи можна використовувати jQuery разом з React? Чому так / ні?**  
      Можна, але небажано через прямі маніпуляції DOM.

113.  **Що таке codemod?**  
      Скрипти для автоматичного рефакторингу коду React.

114.  **Чи доводилося налаштовувати проєкт React з нуля? За допомогою яких інструментів ви це робили?**  
      Create React App, Vite, Webpack, Babel.

115.  **Перерахуйте всі бібліотеки, які використовували у зв’язці з React.**  
      React Router, Redux, Recoil, Axios, Styled-components, Material-UI.

116.  **Що найскладніше доводилося реалізовувати за допомогою React?**  
      Оптимізація рендерингу, складна логіка форм та state management.

---
